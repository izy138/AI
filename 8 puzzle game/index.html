<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8-Puzzle Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #a5c885 100%;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: #648b34;
            color: white;
            padding: 10px;
            text-align: center;
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .main-content {
            display: flex;
            gap: 30px;
            padding: 30px;
        }

        .left-panel {
            flex: 1;
        }

        .right-panel {
            flex: 1;
        }

        .upload-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border: 2px dashed #ddd;
            text-align: center;
            transition: all 0.3s ease;
        }

        .upload-section:hover {
            border-color: #2196F3;
            background: #f0f8ff;
        }

        .upload-section input[type="file"] {
            display: none;
        }

        .upload-btn {
            background: #2196F3;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .upload-btn:hover {
            background: #1976D2;
            transform: translateY(-2px);
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .btn.shuffle {
            background: #FF9800;
        }

        .btn.solve {
            background: #9C27B0;
        }

        .btn.reset {
            background: #F44336;
        }

        .puzzle-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        .puzzle-grid {
            display: grid;
            grid-template-columns: repeat(3, 120px);
            grid-template-rows: repeat(3, 120px);
            gap: 3px;
            background: #333;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .puzzle-tile {
            background-size: 360px 360px;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .puzzle-tile:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .puzzle-tile.empty {
            background: #222;
            cursor: default;
        }

        .puzzle-tile.empty:hover {
            transform: none;
            box-shadow: none;
        }

        .tile-number {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
        }

        .info-panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }

        .info-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .solution-display {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            max-height: 1000px;
            overflow-y: auto;
        }

        .solution-step {
            background: white;
            margin-bottom: 10px;
            padding: 10px;
            /* border-radius: 5px; */
            border-left: 4px solid #4CAF50;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .loading::after {
            content: '...';
            animation: dots 2s infinite;
        }

        @keyframes dots {

            0%,
            20% {
                content: '.';
            }

            40% {
                content: '..';
            }

            60%,
            100% {
                content: '...';
            }
        }

        .success-message {
            background: #4CAF50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            margin-bottom: 20px;
            animation: slideIn 0.5s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .algorithm-selector {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .algorithm-selector label {
            font-weight: bold;
            color: #333;
        }

        .algorithm-selector select {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 5px;
            background: white;
            font-size: 14px;
            cursor: pointer;
            transition: border-color 0.3s ease;
        }

        .algorithm-selector select:focus {
            outline: none;
            border-color: #2196F3;
        }

        .algorithm-info {
            background: #e3f2fd;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .algorithm-info h3 {
            color: #1565C0;
            margin-bottom: 15px;
        }

        .comparison-results {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border: 2px solid #2196F3;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            /* border: 2px solid #2196F3; */
        }

        .comparison-table th,
        .comparison-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .comparison-table th {
            background-color: #2196F3;
            color: white;
            font-weight: bold;
        }

        .comparison-table tr:nth-child(even) {
            background-color: #f2f2f2;
        }

        .comparison-table tr:hover {
            background-color: #e3f2fd;
        }

        .best-result {
            background-color: #c8e6c9 !important;
            font-weight: bold;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
                padding: 15px;
            }

            .puzzle-grid {
                grid-template-columns: repeat(3, 80px);
                grid-template-rows: repeat(3, 80px);
            }

            .controls {
                justify-content: center;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>8-Puzzle Game</h1>
            <p>Upload an image and solve the puzzle using different algorithms</p>
        </div>

        <div class="main-content">
            <div class="left-panel">

                <div class="puzzle-container">
                    <div class="puzzle-grid" id="puzzleGrid">
                        <!-- Puzzle tiles will be generated here -->
                    </div>
                </div>

                <div class="upload-section">
                    <h3>Upload Your Image</h3>
                    <p>Choose an image to create your puzzle</p>
                    <br>
                    <input type="file" id="imageUpload" accept="image/*">
                    <button class="upload-btn" onclick="document.getElementById('imageUpload').click()">
                        Choose Image
                    </button>
                </div>



                <div class="algorithm-info">
                    <h3 id="algorithmTitle">Algorithm: A* with Manhattan Distance Heuristic</h3>
                    <p id="algorithmDescription">This implementation uses the A* search algorithm with Manhattan
                        distance as the heuristic function. Manhattan distance calculates the sum of horizontal and
                        vertical distances each tile needs to move to reach its goal position, providing an admissible
                        and efficient heuristic for solving the 8-puzzle.</p>
                </div>

                <div id="comparisonResults" class="comparison-results" style="display: none;">
                    <h3>Algorithm Comparison Results</h3>
                    <table class="comparison-table">
                        <thead>
                            <tr>
                                <th>Algorithm</th>
                                <th>Steps</th>
                                <th>Nodes Explored</th>
                                <th>Time (ms)</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody id="comparisonTableBody">
                        </tbody>
                    </table>
                    <p style="margin-top: 15px; font-size: 14px; color: #666;">
                        <strong>Green highlighting</strong> indicates the best performance in each category.
                    </p>
                </div>
            </div>

            <div class="right-panel">

                <div class="algorithm-selector">
                    <label for="algorithmSelect">Choose Algorithm:</label>
                    <select id="algorithmSelect">
                        <option value="astar">A* (Manhattan Distance)</option>
                        <option value="bfs">BFS (Breadth-First Search)</option>
                        <option value="dfs">DFS (Depth-First Search - Limited)</option>
                    </select>
                </div>

                <div class="controls">
                    <button class="btn shuffle" onclick="shufflePuzzle()">Shuffle Puzzle</button>
                    <button class="btn solve" onclick="solvePuzzle()">Find Solution</button>
                    <button class="btn" onclick="compareAllAlgorithms()" id="compareBtn"
                        style="background: #795548;">Compare All</button>

                    <button class="btn" onclick="playNextStep()" id="nextStepBtn" disabled>Next Step</button>
                    <button class="btn reset" onclick="resetPuzzle()">Reset</button>
                </div>



                <div class="info-panel">
                    <h3>Game Information</h3>
                    <div class="info-item">
                        <span>Moves:</span>
                        <span id="moveCount">0</span>
                    </div>
                    <div class="info-item">
                        <span>Status:</span>
                        <span id="gameStatus">Ready</span>
                    </div>
                    <div class="info-item">
                        <span>Algorithm:</span>
                        <span id="currentAlgorithm">A* Search</span>
                    </div>
                    <div class="info-item">
                        <span>Heuristic:</span>
                        <span id="heuristicDisplay">Manhattan Distance</span>
                    </div>
                </div>

                <div class="solution-display">
                    <h3>Solution Steps</h3>
                    <div id="solutionSteps">
                        <p>Upload an image and click "Find Solution" to see the optimal path.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentState = [1, 2, 3, 4, 5, 6, 7, 8, 0];
        let goalState = [1, 2, 3, 4, 5, 6, 7, 8, 0];
        let currentImage = null;
        let moveCount = 0;
        let solution = [];
        let currentSolutionStep = 0;

        // Initialize puzzle grid
        function initializePuzzle() {
            const grid = document.getElementById('puzzleGrid');
            grid.innerHTML = '';

            for (let i = 0; i < 9; i++) {
                const tile = document.createElement('div');
                tile.className = 'puzzle-tile';
                tile.onclick = () => handleTileClick(i);
                grid.appendChild(tile);
            }

            updateDisplay();
        }

        // Handle image upload
        document.getElementById('imageUpload').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (event) {
                processImage(event.target.result);
            };
            reader.readAsDataURL(file);
        });

        // Process and scale image to fit puzzle grid
        function processImage(imageSrc) {
            const img = new Image();
            img.onload = function () {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                // Set canvas size to puzzle dimensions
                canvas.width = 360; // 3x3 grid of 120px tiles
                canvas.height = 360;

                // Calculate scaling to fit image while maintaining aspect ratio
                const imgAspect = img.width / img.height;
                const canvasAspect = 1; // Square canvas

                let drawWidth, drawHeight, drawX, drawY;

                if (imgAspect > canvasAspect) {
                    // Image is wider - fit to height
                    drawHeight = canvas.height;
                    drawWidth = drawHeight * imgAspect;
                    drawX = (canvas.width - drawWidth) / 2;
                    drawY = 0;
                } else {
                    // Image is taller - fit to width
                    drawWidth = canvas.width;
                    drawHeight = drawWidth / imgAspect;
                    drawX = 0;
                    drawY = (canvas.height - drawHeight) / 2;
                }

                // Fill canvas with black background
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw scaled image
                ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);

                // Store the processed image
                currentImage = canvas.toDataURL();
                resetPuzzle();
                updateStatus('Image loaded and scaled! You can now shuffle and play.');
            };
            img.src = imageSrc;
        }

        // Update puzzle display
        function updateDisplay() {
            const tiles = document.querySelectorAll('.puzzle-tile');

            tiles.forEach((tile, index) => {
                const value = currentState[index];
                tile.innerHTML = '';

                if (value === 0) {
                    // Empty tile - clear all styles and show as empty
                    tile.className = 'puzzle-tile empty';
                    tile.style.backgroundImage = 'none';
                    tile.style.background = '#222';
                    tile.style.display = 'block';
                } else {
                    tile.className = 'puzzle-tile';

                    if (currentImage) {
                        // Calculate the position of this tile piece in the original image
                        const row = Math.floor((value - 1) / 3);
                        const col = (value - 1) % 3;

                        tile.style.backgroundImage = `url(${currentImage})`;
                        tile.style.backgroundPosition = `${-col * 120}px ${-row * 120}px`;
                        tile.style.backgroundSize = '360px 360px'; // Full puzzle size
                        tile.style.backgroundRepeat = 'no-repeat';
                    } else {
                        // Default colored tiles with numbers
                        tile.style.backgroundImage = 'none';
                        tile.style.background = `hsl(${value * 40}, 70%, 60%)`;
                        tile.style.display = 'flex';
                        tile.style.alignItems = 'center';
                        tile.style.justifyContent = 'center';
                        tile.style.fontSize = '24px';
                        tile.style.fontWeight = 'bold';
                        tile.style.color = 'white';
                        tile.textContent = value;
                    }

                    // Add tile number overlay (only for non-empty tiles)
                    const numberOverlay = document.createElement('div');
                    numberOverlay.className = 'tile-number';
                    numberOverlay.textContent = value;
                    tile.appendChild(numberOverlay);
                }
            });

            document.getElementById('moveCount').textContent = moveCount;

            if (isPuzzleSolved()) {
                showSuccess();
            }
        }

        // Handle tile clicks
        function handleTileClick(index) {
            const emptyIndex = currentState.indexOf(0);

            if (isValidMove(index, emptyIndex)) {
                // Swap tiles
                [currentState[index], currentState[emptyIndex]] = [currentState[emptyIndex], currentState[index]];
                moveCount++;
                updateDisplay();
            }
        }

        // Check if move is valid
        function isValidMove(tileIndex, emptyIndex) {
            const tileRow = Math.floor(tileIndex / 3);
            const tileCol = tileIndex % 3;
            const emptyRow = Math.floor(emptyIndex / 3);
            const emptyCol = emptyIndex % 3;

            return Math.abs(tileRow - emptyRow) + Math.abs(tileCol - emptyCol) === 1;
        }

        // Shuffle puzzle
        function shufflePuzzle() {
            // Start from solved state and make random valid moves
            currentState = [...goalState];

            for (let i = 0; i < 500; i++) {
                const emptyIndex = currentState.indexOf(0);
                const validMoves = [];

                // Find all valid moves
                for (let j = 0; j < 9; j++) {
                    if (isValidMove(j, emptyIndex)) {
                        validMoves.push(j);
                    }
                }

                // Make a random valid move
                if (validMoves.length > 0) {
                    const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                    [currentState[randomMove], currentState[emptyIndex]] = [currentState[emptyIndex], currentState[randomMove]];
                }
            }

            moveCount = 0;
            solution = [];
            currentSolutionStep = 0;
            updateDisplay();
            updateStatus('Puzzle shuffled! Start solving or click "Find Solution".');
            document.getElementById('solutionSteps').innerHTML = '<p>Click "Find Solution" to see the optimal path.</p>';
        }

        // A* Algorithm Implementation
        class PuzzleNode {
            constructor(state, parent = null, move = null, depth = 0) {
                this.state = [...state];
                this.parent = parent;
                this.move = move;
                this.depth = depth;
                this.heuristic = this.calculateManhattanDistance();
                this.f = this.depth + this.heuristic;
            }

            calculateManhattanDistance() {
                let distance = 0;
                for (let i = 0; i < 9; i++) {
                    if (this.state[i] !== 0) {
                        const currentRow = Math.floor(i / 3);
                        const currentCol = i % 3;
                        const targetPos = this.state[i] - 1;
                        const targetRow = Math.floor(targetPos / 3);
                        const targetCol = targetPos % 3;
                        distance += Math.abs(currentRow - targetRow) + Math.abs(currentCol - targetCol);
                    }
                }
                return distance;
            }

            getStateString() {
                return this.state.join(',');
            }

            getNeighbors() {
                const neighbors = [];
                const emptyIndex = this.state.indexOf(0);
                const emptyRow = Math.floor(emptyIndex / 3);
                const emptyCol = emptyIndex % 3;

                const directions = [
                    { row: -1, col: 0, name: 'UP' },
                    { row: 1, col: 0, name: 'DOWN' },
                    { row: 0, col: -1, name: 'LEFT' },
                    { row: 0, col: 1, name: 'RIGHT' }
                ];

                for (const dir of directions) {
                    const newRow = emptyRow + dir.row;
                    const newCol = emptyCol + dir.col;

                    if (newRow >= 0 && newRow < 3 && newCol >= 0 && newCol < 3) {
                        const newIndex = newRow * 3 + newCol;
                        const newState = [...this.state];
                        [newState[emptyIndex], newState[newIndex]] = [newState[newIndex], newState[emptyIndex]];

                        neighbors.push(new PuzzleNode(newState, this, dir.name, this.depth + 1));
                    }
                }

                return neighbors;
            }
        }

        // A* Search Implementation
        function aStarSearch(start, goal) {
            const startNode = new PuzzleNode(start);
            const goalString = goal.join(',');

            if (startNode.getStateString() === goalString) {
                return { path: [], nodesExplored: 0, algorithm: 'A*' };
            }

            const openSet = [startNode];
            const closedSet = new Set();
            const gScores = new Map();
            gScores.set(startNode.getStateString(), 0);

            let nodesExplored = 0;

            while (openSet.length > 0) {
                // Find node with lowest f score
                openSet.sort((a, b) => a.f - b.f);
                const currentNode = openSet.shift();
                const currentString = currentNode.getStateString();

                if (currentString === goalString) {
                    // Reconstruct path
                    const path = [];
                    let node = currentNode;
                    while (node.parent) {
                        path.unshift({ move: node.move, state: [...node.state] });
                        node = node.parent;
                    }
                    return { path, nodesExplored, algorithm: 'A*' };
                }

                closedSet.add(currentString);
                nodesExplored++;

                // Explore neighbors
                for (const neighbor of currentNode.getNeighbors()) {
                    const neighborString = neighbor.getStateString();

                    if (closedSet.has(neighborString)) {
                        continue;
                    }

                    const tentativeGScore = currentNode.depth + 1;
                    const existingGScore = gScores.get(neighborString);

                    if (existingGScore === undefined || tentativeGScore < existingGScore) {
                        gScores.set(neighborString, tentativeGScore);

                        // Remove existing node with same state from openSet
                        const existingIndex = openSet.findIndex(node => node.getStateString() === neighborString);
                        if (existingIndex !== -1) {
                            openSet.splice(existingIndex, 1);
                        }

                        openSet.push(neighbor);
                    }
                }

                // Prevent infinite loops in case of complex puzzles
                if (nodesExplored > 100000) {
                    break;
                }
            }

            return { path: [], nodesExplored, algorithm: 'A*' };
        }

        function bfsSearch(start, goal) {
            const startString = start.join(',');
            const goalString = goal.join(',');

            if (startString === goalString) {
                return { path: [], nodesExplored: 0, algorithm: 'BFS' };
            }

            // Forward search from start
            const forwardQueue = [new PuzzleNode(start)];
            const forwardVisited = new Map();
            forwardVisited.set(startString, new PuzzleNode(start));

            // Backward search from goal  
            const backwardQueue = [new PuzzleNode(goal)];
            const backwardVisited = new Map();
            backwardVisited.set(goalString, new PuzzleNode(goal));

            let nodesExplored = 0;

            while (forwardQueue.length > 0 && backwardQueue.length > 0) {
                // Alternate between forward and backward search
                const currentQueue = forwardQueue.length <= backwardQueue.length ? forwardQueue : backwardQueue;
                const currentVisited = currentQueue === forwardQueue ? forwardVisited : backwardVisited;
                const otherVisited = currentQueue === forwardQueue ? backwardVisited : forwardVisited;

                const currentNode = currentQueue.shift();
                nodesExplored++;

                const currentString = currentNode.getStateString();

                // Check if we've found a connection
                if (otherVisited.has(currentString)) {
                    // Reconstruct path by combining forward and backward paths
                    const path = [];

                    if (currentQueue === forwardQueue) {
                        // Forward path
                        let node = currentNode;
                        const forwardPath = [];
                        while (node.parent) {
                            forwardPath.unshift({ move: node.move, state: [...node.state] });
                            node = node.parent;
                        }

                        // Backward path (reversed)
                        node = otherVisited.get(currentString);
                        const backwardPath = [];
                        while (node.parent) {
                            backwardPath.push({ move: node.move, state: [...node.state] });
                            node = node.parent;
                        }

                        path.push(...forwardPath, ...backwardPath.reverse());
                    } else {
                        // Similar logic but reversed
                        let node = otherVisited.get(currentString);
                        const forwardPath = [];
                        while (node.parent) {
                            forwardPath.unshift({ move: node.move, state: [...node.state] });
                            node = node.parent;
                        }

                        node = currentNode;
                        const backwardPath = [];
                        while (node.parent) {
                            backwardPath.push({ move: node.move, state: [...node.state] });
                            node = node.parent;
                        }

                        path.push(...forwardPath, ...backwardPath.reverse());
                    }

                    return { path, nodesExplored, algorithm: 'BFS' };
                }

                // Expand neighbors
                const neighbors = currentNode.getNeighbors();
                for (const neighbor of neighbors) {
                    const neighborString = neighbor.getStateString();
                    if (!currentVisited.has(neighborString)) {
                        currentVisited.set(neighborString, neighbor);
                        currentQueue.push(neighbor);
                    }
                }

                // Timeout check
                if (nodesExplored > 100000) {
                    return { path: [], nodesExplored, algorithm: 'BFS', timeout: true };
                }
            }

            return { path: [], nodesExplored, algorithm: 'BFS' };
        }

        function dfsSearch(start, goal, maxDepth = 50) {
            const startNode = new PuzzleNode(start);
            const goalString = goal.join(',');

            if (startNode.getStateString() === goalString) {
                return { path: [], nodesExplored: 0, algorithm: 'DFS' };
            }

            let totalNodesExplored = 0;
            const maxAttempts = 5; // Try 5 different random paths

            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                const visited = new Set();
                let nodesExplored = 0;
                let solutionPath = null;

                function dfsRecursive(node, depth) {
                    if (depth >= maxDepth) return false;
                    if (solutionPath) return true;
                    if (nodesExplored > 5000) return false; // Limit per attempt

                    const nodeString = node.getStateString();
                    visited.add(nodeString);
                    nodesExplored++;
                    totalNodesExplored++;

                    if (nodeString === goalString) {
                        solutionPath = [];
                        let current = node;
                        while (current.parent) {
                            solutionPath.unshift({ move: current.move, state: [...current.state] });
                            current = current.parent;
                        }
                        return true;
                    }

                    const neighbors = node.getNeighbors();
                    // Randomize neighbor order for different attempts
                    for (let i = neighbors.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [neighbors[i], neighbors[j]] = [neighbors[j], neighbors[i]];
                    }

                    for (const neighbor of neighbors) {
                        const neighborString = neighbor.getStateString();
                        if (!visited.has(neighborString)) {
                            if (dfsRecursive(neighbor, depth + 1)) {
                                return true;
                            }
                        }
                    }

                    visited.delete(nodeString);
                    return false;
                }

                if (dfsRecursive(startNode, 0)) {
                    return {
                        path: solutionPath,
                        nodesExplored: totalNodesExplored,
                        algorithm: 'DFS',
                        depthLimited: maxDepth
                    };
                }
            }

            return {
                path: [],
                nodesExplored: totalNodesExplored,
                algorithm: 'DFS',
                depthLimited: maxDepth
            };
        }
        // Solve puzzle using selected algorithm
        async function solvePuzzle() {
            if (isPuzzleSolved()) {
                updateStatus('Puzzle is already solved!');
                return;
            }

            const selectedAlgorithm = document.getElementById('algorithmSelect').value;
            updateStatus(`Solving puzzle using ${selectedAlgorithm.toUpperCase()}...`);
            document.getElementById('solutionSteps').innerHTML = '<div class="loading">Finding solution</div>';

            // Use setTimeout to allow UI to update
            setTimeout(() => {
                const startTime = performance.now();
                let result;

                switch (selectedAlgorithm) {
                    case 'astar':
                        result = aStarSearch([...currentState], goalState);
                        break;
                    case 'bfs':
                        result = bfsSearch([...currentState], goalState);
                        break;
                    case 'dfs':
                        result = dfsSearch([...currentState], goalState);
                        break;
                    default:
                        result = aStarSearch([...currentState], goalState);
                }

                const endTime = performance.now();
                const solveTime = endTime - startTime;

                if (result.path.length > 0) {
                    solution = result.path;
                    currentSolutionStep = 0;
                    displaySolution(result, solveTime);

                    let statusMessage = `${result.algorithm} found solution! ${result.path.length} moves, ${result.nodesExplored} nodes explored in ${Math.round(solveTime)}ms`;
                    if (result.timeout) {
                        statusMessage += ' (search limited to prevent timeout)';
                    }
                    if (result.depthLimited) {
                        statusMessage += ` (depth limited to ${result.depthLimited})`;
                    }

                    updateStatus(statusMessage);
                    document.getElementById('nextStepBtn').disabled = false;
                } else {
                    let errorMessage = `${result.algorithm || selectedAlgorithm.toUpperCase()} could not find solution`;
                    if (result.timeout) {
                        errorMessage += ' (search timeout to prevent browser freeze)';
                    } else if (result.depthLimited) {
                        errorMessage += ` (no solution within depth limit of ${result.depthLimited})`;
                    }

                    updateStatus(errorMessage);
                    document.getElementById('solutionSteps').innerHTML = `<p>${errorMessage}. Try A* for guaranteed optimal solution.</p>`;
                }
            }, 100);
        }


        // Display solution steps
        function displaySolution(result, solveTime) {
            const container = document.getElementById('solutionSteps');
            let html = `
                <div style="background: white; padding: 10px; border-radius: 5px; margin-bottom: 10px; margin-top: 10px; border-left: 4px solid #4CAF50;">
                    <strong>${result.algorithm} Solution Found!</strong><br>
                    Steps: ${result.path.length}<br>
                    Nodes explored: ${result.nodesExplored}<br>
                    Time: ${Math.round(solveTime)}ms
                    ${result.timeout ? '<br><span style="color: #FF9800;">⚠️ Search limited to prevent timeout</span>' : ''}
                    ${result.depthLimited ? `<br><span style="color: #FF9800;">⚠️ Depth limited to ${result.depthLimited}</span>` : ''}
                </div>
            `;

            result.path.forEach((step, index) => {
                html += `
                    <div class="solution-step" id="step-${index}">
                        <strong>Step ${index + 1}:</strong> Move ${step.move}
                        <div style="font-size: 12px; margin-top: 5px; font-family: monospace;">
                            ${formatStateForDisplay(step.state)}
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        async function compareAllAlgorithms() {
            if (isPuzzleSolved()) {
                updateStatus('Please shuffle the puzzle first before comparing algorithms!');
                return;
            }

            updateStatus('Running all algorithms for comparison...');
            document.getElementById('solutionSteps').innerHTML = '<div class="loading">Comparing A*, BFS, and DFS algorithms</div>';

            const testState = [...currentState];
            const results = [];

            try {
                // Test A* Algorithm
                console.log('Testing A*...');
                const startTime1 = performance.now();
                const astarResult = aStarSearch(testState, goalState);
                const endTime1 = performance.now();
                astarResult.time = Math.round(endTime1 - startTime1);
                results.push(astarResult);
                console.log('A* completed:', astarResult);

                // Test BFS Algorithm  
                console.log('Testing BFS...');
                const startTime2 = performance.now();
                const bfsResult = bfsSearch(testState, goalState);
                const endTime2 = performance.now();
                bfsResult.time = Math.round(endTime2 - startTime2);
                results.push(bfsResult);
                console.log('BFS completed:', bfsResult);

                // Test DFS Algorithm
                console.log('Testing DFS...');
                const startTime3 = performance.now();
                const dfsResult = dfsSearch(testState, goalState, 50);
                const endTime3 = performance.now();
                dfsResult.time = Math.round(endTime3 - startTime3);
                results.push(dfsResult);
                console.log('DFS completed:', dfsResult);

                // Display results
                displayComparisonResults(results);
                updateStatus('Algorithm comparison completed!');

                // Set best solution
                const bestResult = results.find(r => r.algorithm === 'A*' && r.path.length > 0) ||
                    results.find(r => r.path.length > 0);
                if (bestResult && bestResult.path.length > 0) {
                    solution = bestResult.path;
                    currentSolutionStep = 0;
                    document.getElementById('nextStepBtn').disabled = false;
                }

            } catch (error) {
                console.error('Error in comparison:', error);
                updateStatus('Error during algorithm comparison');
            }
        }

        function formatStateForDisplay(state) {
            let result = '';
            for (let i = 0; i < 9; i++) {
                if (i % 3 === 0 && i > 0) result += '<br>';
                result += (state[i] === 0 ? '_' : state[i]) + ' ';
            }
            return result;
        }

        // Play next solution step
        function playNextStep() {
            if (currentSolutionStep < solution.length) {
                currentState = [...solution[currentSolutionStep].state];
                updateDisplay();

                // Highlight current step
                document.querySelectorAll('.solution-step').forEach((step, index) => {
                    step.style.background = index === currentSolutionStep ? '#e3f2fd' : 'white';
                });

                currentSolutionStep++;

                if (currentSolutionStep >= solution.length) {
                    document.getElementById('nextStepBtn').disabled = true;
                    updateStatus('Solution completed!');
                }
            }
        }

        // Check if puzzle is solved
        function isPuzzleSolved() {
            return currentState.every((value, index) => value === goalState[index]);
        }

        // Reset puzzle
        function resetPuzzle() {
            currentState = [...goalState];
            moveCount = 0;
            solution = [];
            currentSolutionStep = 0;
            updateDisplay();
            updateStatus('Puzzle reset to solved state.');
            document.getElementById('nextStepBtn').disabled = true;
            document.getElementById('solutionSteps').innerHTML = '<p>Upload an image and click "Find Solution" to see the optimal path.</p>';
        }

        // Update status
        function updateStatus(message) {
            document.getElementById('gameStatus').textContent = message;
        }

        // Show success message
        function showSuccess() {
            const existingMessage = document.querySelector('.success-message');
            if (existingMessage) return;

            const message = document.createElement('div');
            message.className = 'success-message';
            message.textContent = `Congratulations! Puzzle solved in ${moveCount} moves!`;

            const container = document.querySelector('.left-panel');
            container.insertBefore(message, container.firstChild);

            setTimeout(() => {
                if (message.parentNode) {
                    message.parentNode.removeChild(message);
                }
            }, 5000);

            updateStatus('Puzzle solved!');
        }

        // Update algorithm info when selection changes
        document.getElementById('algorithmSelect').addEventListener('change', function () {
            const algorithm = this.value;
            const titleElement = document.getElementById('algorithmTitle');
            const descElement = document.getElementById('algorithmDescription');
            const currentAlgElement = document.getElementById('currentAlgorithm');
            const heuristicElement = document.getElementById('heuristicDisplay');

            switch (algorithm) {
                case 'astar':
                    titleElement.textContent = 'Algorithm: A* with Manhattan Distance Heuristic';
                    descElement.textContent = 'A* uses Manhattan distance heuristic to find optimal solutions efficiently. It combines the actual cost to reach a state with an estimated cost to the goal, guaranteeing the shortest path while exploring fewer nodes than uninformed search.';
                    currentAlgElement.textContent = 'A* Search';
                    heuristicElement.textContent = 'Manhattan Distance';
                    break;
                case 'bfs':
                    titleElement.textContent = 'Algorithm: Breadth-First Search (BFS)';
                    descElement.textContent = 'BFS explores all nodes at the current depth before moving to nodes at the next depth. It guarantees finding the optimal solution but may explore many more nodes than A*. It uses no heuristic information.';
                    currentAlgElement.textContent = 'BFS';
                    heuristicElement.textContent = 'None (Uninformed)';
                    break;
                case 'dfs':
                    titleElement.textContent = 'Algorithm: Depth-First Search (DFS) - Limited Depth';
                    descElement.textContent = 'DFS explores as far as possible along each branch before backtracking. For 8-puzzle, we limit the depth to prevent infinite loops. DFS does not guarantee optimal solutions and may find longer paths.';
                    currentAlgElement.textContent = 'DFS (Limited)';
                    heuristicElement.textContent = 'None (Uninformed)';
                    break;
            }
        });

        // Initialize the game
        initializePuzzle();
        updateStatus('Upload an image to start playing!');
    </script>
</body>

</html>